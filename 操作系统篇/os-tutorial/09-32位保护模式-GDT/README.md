# 32位保护模式-GDT


## 概念

**GDT**: Global Descriptor Table，全局描述符表


## 目标

**编写GDT**

还记得第六课的分段吗？偏移量左移以处理额外的间接层。

在32位模式下，分段的工作方式有所不同。现在，偏移量成为GDT中一个分段描述符(SD)的索
引。这个描述符定义了基本地址(32位)、大小(20位)和一些标志位，比如readonly、权限等
等。为了进行混淆，这个数据结构被进行了分割，所以打开`os-dev.pdf`文件看看第34页上
的图或维基百科的GDT页面。

![SD](https://raw.githubusercontent.com/garenchan/my-worklog/master/操作系统篇/os-tutorial/09-32位保护模式-GDT/segment-descriptor-structure.png)

编写GDT最简单的方法是定义两个段，一个用于代码，另一个用于数据。这些段可能会重叠，
这意味着没有进行内存保护，但对于引导来说它已经足够了，我们稍后将用更高级的语言来
修复它。

出于好奇，第一个GDT条目必须是`0x00`，以确保程序员在管理地址时不会出错。

此外，CPU不能直接加载GDT地址，但它需要一个名为“GDT描述符”的元结构，其包含了实际
GDT的大小(16b)和地址(32b)。我们可以使用`lgdt`操作符来加载它。

让我们直接跳到使用汇编语言编写的GDT代码。同样，要理解所有分段标志，请参考`os-dev.pdf`
文档。这一课的原理相当复杂。

在下一节课中，我们将切换到32位保护模式，并测试我们在这些课程中编写的代码。
