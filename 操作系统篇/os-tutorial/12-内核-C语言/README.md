# 内核-C语言


## 概念

C语言、目标代码、链接器、反汇编


## 目标

**学习使用C语言编写与之前使用汇编语言相同的低级代码**


## 编译

让我们看看C编译器如何编译我们的代码，并将其与与汇编器生成的机器码进行比较。

我们将开始编写一个只包含一个函数的简单程序`function.c`。打开文件并检查它。

要编译平台无关的代码，我们需要标志`-ffreestanding`，因此以如下方式需要编译`function.c`：

`i386-elf-gcc -ffreestanding -c function.c -o function.o`

让我们检查一下编译器生成的机器码：

`i386-elf-objdump -d function.o`

这是我们认识的东西，不是吗?


## 链接

最后，为了生成二进制文件，我们将使用链接器。这个步骤的一个重要部分是了解高级语言
是如何调用函数标签的。它是我们的函数在内存中的偏移量吗？我们并不知道。对于本例，
我们将把偏移量设置在`0x0`并使用`binary`格式，它会生成不带任何标签或元数据的机器码。

`i386-elf-ld -o function.bin -Ttext 0x0 --oformat binary function.o`

注意：链接时可能会出现警告，请忽略它。

现在使用`xxd`检查两个二进制文件`function.o`和`function.bin`。您将看到`.bin`文件是
机器码，而`.o`文件有许多调试信息、标签等。


## 反编译

出于好奇，我们将检查机器代码。

`ndisasm -b 32 function.bin`


## 更多

本节课还涉及到其他3个小程序。

- 有关局部变量的`localvars.c`
- 有关函数调用的`functioncalls.c`
- 有关指针的`pointers.c`

然后编译和反汇编它们，并检查生成的机器码。遵循os-guide.pdf的解释，试着回答这个问
题：为什么`pointers.c`的反汇编结果不像你预期的那样？“Hello”字符串的ASCII编码`0x48656c6c6f`
又在哪里呢？


## 思考

1. 内存对齐的意义：

> 和硬盘的扇区一样，CPU也有自己读写的基本单位，暂且称为块(可能是2,4,8,16个字节)，
如果数据类型不和块进行对齐的话，可能导致CPU需要通过多次才能完成读取和写入。反之进
行内存对齐的话，可以减少IO次数，达到以空间换时间的目的。

2. 在函数调用返回时，C会使用`leave`指令撤销当前的栈帧，`leave`指令等同于下面2条
指令：

```nasm
mov esp, ebp ; 撤销当前栈帧
pop ebp      ; 将保存的前一个栈帧的基底地址恢复到ebp寄存器，这样就恢复了前一个栈帧
```

我们前面了解到当`esp`等于`ebp`时就是栈为空的情况，那为什么接下来的`pop`操作依旧可
以正常执行了？这应该说明**CPU不会对栈是否为空进行检查**，所以这个工作需要交由高级
语言(例如C)来完成。

3. 反汇编程序无法区分代码和数据，因此我们的数据会被误认为是代码，这也就是`pointers.c`
的反汇编结果中无法找到“Hello”字符串，但是却多出来一些看不懂的代码的原因。
