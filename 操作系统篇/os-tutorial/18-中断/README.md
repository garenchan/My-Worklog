# 中断


## 概念

C语言的类型和结构体，include预处理指令，类型属性：packed、extern、volatile，异常


## 目标

**设置中断描述符表来处理CPU中断**


## 数据类型

首先，我们将在`cpu/types`中定义一些特殊的数据类型，这将帮助我们从chars和int中解耦
原始字节的数据结构。它被小心地放置在`cpu/`文件夹中，从现在开始，我们将在其中放置
依赖于机器的代码。是的，引导代码是`x86`的，并且仍然在`boot/`中，但是我们暂时不讨论
这个问题。

一些已经存在的文件已经更改为使用新的`u8`、`u16`和`u32`数据类型。

从现在开始，我们的C头文件也将包含include预处理指令。


## 中断

中断是内核需要处理的主要事情之一。我们将尽快实现它，以便在以后的课程中能够接收键
盘输入。

中断的另一个例子是：除以0、越界、无效操作码、页面错误等等。

中断是在一个向量上处理的，其条目与GDT的条目类似(第9课)。但是，我们将用C来代替在汇
编中编写IDT。

在`cpu/idt.h`中定义了一个idt条目是如何存储在`idt_gate`(它们需要256个，即使是null，
否则CPU可能会panic)中的，以及BIOS将加载的实际idt结构，`idt_register`就是一个内存
地址和大小，类似于GDT寄存器。

最后，我们定义了几个变量来从汇编代码访问这些数据结构。

`cpu/idt.c`只是用一个处理器填充每个结构体。正如你所看到的，这是一个设置struct值并
调用`lidt`汇编指令的问题。


## 中断服务例程ISR

每次CPU检测到一个中断(通常是致命的)，中断服务例程就会运行。

我们将编写足够的代码来处理它们，打印错误消息，并停止CPU。

在`cpu/isr.h`中我们手动定义了它们中的32个。之所以将它们声明为`extern`，是因为它们
将在汇编代码`cpu/interrupt.asm`中实现。

在跳到汇编代码之前，请检查`cpu/isr.c`。如你所见，我们定义了一个函数来一次性安装所
有ISRs并加载IDT、错误消息列表和高级处理程序(打印一些信息)。你可以自定义`isr_handler`
来打印/做你想做的任何事情。

现在回到低级，它使用低级和高级处理程序粘接每个`idt_gate`。打开`cpu/interrupt.asm`。
这里我们定义了一个通用的低级ISR代码，它基本上保存/恢复状态并调用C代码，然后是`cpu/ ISR.h`
上引用的实际ISR汇编函数。

注意`registers_t`结构是我们在`interrupt.asm`中推入的所有寄存器的一个表示。

基本上是这样。现在我们需要从我们的Makefile中引用`cpu/interrupt.asm`，然后让内核安
装ISRs并启动其中一个。注意CPU是如何不停止的，即使在一些中断之后这样做是一个很好的
实践。


## 思考

1.中断描述符表和中断向量表的区别

中断向量表就是中断服务例程ISR的数组，以中断号作为索引找到的数组元素就是对应的中断
服务例程；而中断描述符表，存放的是中断向量表的起始地址和字节大小（比实际值小1）。
