# Quorum机制

OpenStack的对象存储组件Swift放弃了强一致性，而采用了最终一致性(Eventual Consistency)，
来提升高可用性和高可扩展性。为了实现这一目标，Swift采用了`Quorum`机制。今天就对`Quorum`
机制进行简单的学习。

> 写入一个数据成功后，在读取部分副本时有可能读不到最新数据，但是在某个时间窗口之
> 后保证最终能读到。

`Quorum`机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其
主要思想来源于`鸽巢原理`。


## 鸽巢原理

`鸽巢原理`，又名`狄利克雷抽屉原理`、`鸽笼原理`。

其中一种简单的表述法为:

- 若有n个笼子和n+1只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少2只鸽子。

另一种为:

-若有n个笼子和kn+1只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少k+1只鸽子。

集合论的表述如下:

- 若A是n+1元集，B是n元集，则不存在从A到B的单射。

这个原理通过`反证法`可以很简单的进行证明。


## Quorum定义

在分布式系统中，冗余数据是保证可靠性的手段，因此冗余数据的一致性维护就非常重要。一
般而言，一个写操作必须要对所有的冗余数据都更新完成了，才能称为成功结束，我们称这
种为`WARO`(Write All Read One)机制。比如一份数据在5台设备上有冗余，因为不知道后面的
读操作会落在哪一台设备上，那么一次写操作，必须5台设备都更新完成，才能返回。

对于写比较频繁的系统，写操作的开销会非常大，但是读操作会比较简单，只要读任何一个
副本上的数据即可读取到最新数据。假设有N个副本，N-1个都宕机了，剩下的那个副本仍能
提供读操作；但是只要有一个副本宕机了，写操作就不会成功。

`WARO`牺牲了写服务的可用性，最大程度地提高了读服务的可用性。而`Quorum`则在写服务
和读服务之间进行了折衷，其定义如下:

    分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须不小
    于最小读票数Vr(read quorum)，每个写操作获得的票数必须不小于最小写票数Vw(write quorum)
    才能读或写。如果系统有V票(意味着一份数据有V份冗余拷贝)，那么最小读写票数(quorum)
    应满足如下限制:
    
    1. Vr + Vw > V
    2. Vw > V/2

第一条规则保证了一个数据不会被同时读写。当一个写操作请求过来的时候，它必须获得Vw
个冗余拷贝的许可。而剩下的(V-Vw)不够Vr，因此不能再有读请求过来了。同理，当读请求
已经获得Vr个冗余拷贝的许可时，写请求就无法获得足够的许可了。

第二条规则保证了数据的串行化修改。一份数据的冗余拷贝不可能同时被两个写请求修改。


## Quorum好处

同样是上面的例子，比如一份数据在5台设备上有冗余，`Quorum`可以让写操作只要写完3台
就返回，剩下的由系统内部缓慢同步完成。而读操作，则需要至少读3台，才能保证至少可以
读到一个最新的数据。

`Quorum`的最小读写票数可以用来作为系统在读、写性能方面的一个可调节参数。写票数Vw
越大，则读票数Vr越小，这时候系统读的开销就小。反之写的开销就小。可以看出`WARO`是
`Vw=V`时的一个特例，具体的Vw和Vr取值如何，需要根据具体的业务场景进行选择。
