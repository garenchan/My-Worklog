# 一致性哈希算法


## 算法背景

假设现在有4台K-V Cache服务器，为了保证数据均匀落到各个服务器上，我们对每个服务器
依次编号为0,1,2,3，每当读写缓存时，我们先对Key值进行哈希，然后对4进行取模运算，得
到的结果就是目标服务器的编号:

    h = Hash(key) % 4

这种普通哈希算法的优点是:

1.在各个服务器资源对等且缓存数据随机性比较高的情况下，能做到很好的负载均衡;

> 即使服务器资源不对等或者缓存数据随机性不够，也能通过添加虚拟服务器的方式来实现
> 较好的负载均衡(一台物理服务器可对应多个编号)

缺点也很明显:

1.当服务器宕机或者增加新的服务器时，会导致大量的缓存数据失效，或者需要迁移；即使
只涉及到1台服务器，这种现象也可能十分严重，我们称之为“雪崩”

为了解决这种类似的普通哈希算法在分布式系统中的不足，麻省理工学院在1997年提出了一
致性哈希算法。


## 哈希算法四要素

良好的分布式Cache系统中的哈希算法应该满足以下4个要素:

- 平衡性(Blance)
平衡性是指哈希的结果能尽可能分布到所有的缓冲中去，这样就可以使得所有的缓冲空间都
得到利用。普通哈希算法也能满足这一点。

- 单调性(Monotonicity)
单调性是指如果已有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入系统中，
那么哈希的结果应该保证原有已分派的内容可以被映射到原本的或者新的缓冲中去，而不会
被映射到其他(排除原本分派的缓冲)旧的缓冲中去。

- 分散性(Spread)
在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望
通过哈希过程将内容映射到缓冲中时，由于不同终端所见的缓冲范围有可能不同，从而导致
哈希的结果不一致。最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情
况显然是应该避免的，因为它浪费了缓冲空间。分散性的定义就是上述情况发生的严重程度。
好的哈希算法应该能够尽量避免不一致的情况发生，也就是尽量降低分散性。

- 负载(Load)
负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到
不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。
与分散性一样，这种情况也是应当避免的，因此好的哈希算法应该能够尽量降低缓冲的负荷。

## 一致性哈希

1.不同于普通哈希算法的是，一致性哈希算法并不会对服务器进行简单的编号，而是通过哈
希算法将它们映射到一个0~[2的32次方-1]的圆上

2.然后采用相同的方法求出缓存数据Key值的哈希值，并映射到相同的圆上

3.最后从数据映射的位置开始顺时针查找，将数据缓存到找到的第一个服务器上

![一致性哈希](https://raw.githubusercontent.com/garenchan/my-worklog/master/docs/snapshots/分布式系统/consistent-hash.png)

从上图可以看出，不管当前的服务器有多少台，每次移除或者添加1台服务器，只会对落在其
与逆时针的第一个相邻服务器之间的圆弧上的缓存数据造成影响，也或者说只会对顺时针的
第一个相邻服务器造成影响。**简而言之，不管服务器有多少台，新增或减少1台服务器只会对
系统中的另外1台服务器造成影响，而在普通哈希算法下可能会对现有所有服务器都造成影响。**


## 平衡性问题

假设缓冲数据的Key值随机性比较高，且能够均匀映射到哈希空间圆环上，那么服务器与其逆
时针的第一个相邻服务器之间的弧长(或者弧度)与它的负载和利用率成正比。但是这个弧长
只由哈希算法来决定，却忽略了一些现实因素: 服务器的资源量，譬如A服务器的内存比B服
务器的多很多，那么我们肯定希望更多的数据能落到A服务器上，而实际情况下可能是A的利
用率比B低。那么为了解决这个问题，一致性哈希算法引入了虚拟节点机制，即每个服务器可
以对应哈希空间圆环上的多个节点(分区)。这样我们可以为资源较多的服务器添加更多的虚
拟节点来解决平衡性问题。
