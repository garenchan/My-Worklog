# 读书笔记-高性能MySQL

- InnoDB的MVCC(多版本并发控制)，是通过在每行记录后面保存两个隐藏的列来实现的。这
两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的并不是
实际的时间值，而是系统的版本号(system version number)。每开始一个新的事务，系统版
本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行
记录的版本号进行比较。MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作，
其他两个隔离级别都和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是
符合当前事务版本的数据行，而SERIALIZABLE则会对所有读取的行都加锁。

- InnoDB表示基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过它的二级索引
(secondary index，非主键索引)中必须包含主键列，**所以如果主键列很大的话，其他的所有
索引都会很大**。因此，若表上的索引较多的话，主键应当尽可能的小。

- 选择数据类型的原则：
    - 更小的通常更好：占用更少的硬盘、内存和CPU缓存，处理时需要更少的CPU周期。
    - 简单就好：简单数据类型的操作通常需要更少的CPU周期。
    - 尽量避免NULL：查询更难优化，可为NULL的列使得索引、索引统计和值比较都更复杂。

- VARCHAR vs CHAR
    - VARCHAR类型用于存储可变长字符串，比CHAR节省空间，因为仅使用必要的空间；但是
    VARCHAR需要使用1或2个额外字节记录字符串的长度；另外UPDATE时可能导致页分裂，需
    要做额外的工作，并且会产生碎片。
    - CHAR适合存储很短的字符串，或者所有值都接近同一个长度。

- 有一种情况下ORDER BY字句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。

- Percona Toolkit:
    - pt-duplicate-key-checker: 该工具通过分析表结构来找出冗余和重复的索引。
    - pt-index-usage: 该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操
    作，然后打印出关于索引和查询的报告。
    - pt-query-digest: 查询审查review功能，分析其EXPLAIN出来的执行计划。

- 表的数据存储也可能碎片化，有三种类型的数据碎片：
    - 行碎片(Row fragmentation): 这种碎片指的是数据行被存储为多个地方的多个片段中，
    即使查询只从索引中访问一行记录，行碎片也会导致性能下降。
    - 行间碎片(Intra-row fragmentation): 行间碎片是指逻辑上顺序的页，或者行在磁盘
    上不是顺序存储的。行间碎片对诸如全表扫描和聚簇索引扫描之类的操作有很大的影响，
    因为这些操作原本能够从磁盘上顺序存储的数据中获益。
    - 剩余空间碎片(Free space fragmentation): 剩余空间碎片是指数据页中有大量的空
    余空间。这会导致服务器读取大量不需要的数据，从而造成浪费。

- 在选择索引和编写利用这些索引的查询时，有如下三个原则始终需要记住：
    1. 单行访问是很慢的。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建
    位置引用以提升效率。
    1. 按顺序访问范围数据是很快的。第一，顺序I/O不需要多次磁盘寻道，所以比随机I/O
    要快很多(特别是对机械硬盘)。第二，如果服务器能够按需要顺序读取数据，那么就不
    再需要额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算了。
    1. 索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不
    需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。
